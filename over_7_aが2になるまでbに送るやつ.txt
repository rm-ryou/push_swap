#include "../includes/push_swap.h"
void	check_rb_mid(t_info *info, int mid);
void	check_rrb_mid(t_info *info, int mid);

void	sort_b(t_info *info, int mid)
{
	t_dlist	*cur;
	int		ra_num;

	ra_num = 0;
	while (dlist_size(info->b) > 0)
	{
		cur = info->b->next;
		if (cur->index == mid)
		{
			pa(info);
			ra_num += 1;
			mid -= 1;
		}
		else if (cur->index == info->sorted)
		{
			pa(info);
			ra(info);
			info->sorted += 1;
		}
		else
			rb(info);
	}
	while (ra_num > 0)
	{
		ra(info);
		info->sorted += 1;
		ra_num -= 1;
	}
}


int	get_pivo(t_dlist *list)
{
	t_dlist	*cur;
	int		size;
	int		i;

	cur = list->next;
	size = 0;
	i = 0;
	while (i < dlist_size(list))
	{
		size += cur->index;
		cur = cur->next;
		i += 1;
	}
	return (size / i);
}

bool	push_under10(t_info *info, int pa_num)
{
	t_dlist	*cur;
	int		i = 0;
	int		mid = get_pivo(info->b);
	printf("mid = %d\n", mid);

	pa_num = 0;
	if (dlist_size(info->b) <= 10)
		return (true);
	int	size = dlist_size(info->b);
	while (i < size)
	{
		cur = info->b->next;
		if (cur->index <= mid)
		{
			pa(info);
			pa_num += 1;
		}
		else
			rb(info);
		i += 1;
	}
	push_under10(info, pa_num);
//	sort_b(info, mid);
//	push_to_b(info, pa_num);
}


bool	divide_first(t_info *info, int mid)
{
	t_dlist	*cur;
	int		mid_pre;

	mid_pre = mid;
	if (dlist_size(info->a) <= 2)
		return (true);
	printf("mid     = %d\n", mid);
	while (dlist_size(info->b) != mid - 1)
	{
		cur = info->a->next;
		if (cur->index < mid)
			check_rb_mid(info, (mid -mid_pre) / 2 + mid_pre);
		else if (info->a->prev->index < mid)
			rra(info);
		else
			ra(info);
	}
	check_rrb_mid(info, (mid -mid_pre) / 2 + mid_pre);
	mid += dlist_size(info->a) / 2;
//	push_under10(info, 0);	//分けた時にソートさせてdividefirstが終わったらall pa
	divide_first(info, mid);
	printf("mid = %d\n", mid);
}

void	sort_over7(t_info *info)
{
	divide_first(info, dlist_size(info->a) / 2 + 1);
	print_list_b(info);
	print_list_a(info);
}

void	check_rrb_mid(t_info *info, int mid)
{
	t_dlist	*cur;

	cur = info->b->prev;
	while (cur->index >= mid)
	{
		rrb(info);
		cur = info->b->prev;
	}
	info->b->next->is_mid = true;
}

void	check_rb_mid(t_info *info, int mid)
{
	t_dlist	*cur;

	pb(info);
	cur = info->b->next;
	if (dlist_size(info->b) == 1)
		return ;
	else if (cur->index >= mid)
		rb(info);
}